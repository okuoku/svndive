(library (svndive util-propfile)
         (export xform-propfile!
                 make-propfile-compress)
         (import (yuni scheme)
                 (yuni hashtables))
;;

(define (xform-propfile! prop replace!)
  (when (pair? prop)
    (let nodeloop ((q prop))
     (let ((node (car q))
           (next (cdr q)))
       (let proploop ((l node))
        (when (pair? l)
          (cond
            ((and (pair? (car l)) (or (string? (caar l)) (symbol? (caar l))))
             (replace! (car l)))
            ((and (pair? (car l)) (pair? (caar l)))
             (proploop (car l))))
          (proploop (cdr l))))
       (when (pair? next)
         (nodeloop next))))))

(define (gen-slash-loc-list str)
  (let ((len (string-length str)))
   (let loop ((idx 0)
              (cur '()))
     (if (= idx len)
       cur
       (let ((c (string-ref str idx)))
        (loop (+ idx 1)
              (if (char=? #\/ c)
                (cons idx cur)
                cur)))))))

(define (split-path e)
  (let ((loc* (gen-slash-loc-list e)))
   (let loop ((q loc*)
              (pos (string-length e))
              (cur '()))
     (if (pair? q)
       (let ((start (car q))
             (next (cdr q)))
         (loop next start (cons (substring e start pos) cur)))
       (cons (substring e 0 pos) cur)))))

(define (make-propfile-compress ht)
  (let ((cnt 0))
   (lambda (p)
     (define (xform-path e) ;; FIXME: Unused. Inefficient.
       (let ((p* (map xform (split-path e))))
        (list->vector p*)))
     (define (xform e)
       (cond
         ((string? e)
          (let ((i (hashtable-ref ht e #f)))
           (cond
             (i i)
             (else
               (let ((mycnt cnt))
                (hashtable-set! ht e mycnt)
                (set! cnt (+ mycnt 1))
                mycnt)))))
         ((symbol? e) #f)
         (else (error "Invalid pair" p))))
     (let ((a (car p))
           (b (cdr p)))
       (cond ((and (symbol? a)
                   (or (eq? 'Text-content-length a)
                       (eq? 'Prop-content-length a)
                       (eq? 'Content-length a)))
              (unless (string? (cdr p))
                (error "Invalid pair??" p))
              ;; We no longer need any length informations
              (set-cdr! p #f))
             (else
               (let ((ea (xform a))
                     (eb (xform b)))
                 (when ea (set-car! p ea))
                 (when eb (set-cdr! p eb)))))))))
)
